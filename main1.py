#Курс по фастапи
# https://www.youtube.com/watch?v=G0pcbxMsiec&list=PLeLN0qH0-mCVQKZ8-W1LhxDcVlWtTALCS&index=2
#видос для создания биржи труда на фаст апи за час
# https://www.youtube.com/watch?v=PVebRy0_K0s
#создание виртуального окружения
#python -m venv venv , в линукс python3 скорее всего писать
#venv/bin/activate - активация виртуального окружения в линукс
#venv\Scripts\activate - активация виртуального окружения в винде
#без активации виртуального окружения не запускается сервер uvicorn
# starlette - это асинхронный фреймворк это фундамент для фастапи
# uvicorn - это библиотека позволяет запускать вебсервер принимать запросы и отправлять ответы на запросы

# from fastapi import FastAPI
#сделали объект приложения нашего
# app = FastAPI()#в скобках пишется имя приложения то есть титле
# #далее создаем точку входа, куда будут обращаться пользователи и получать данные
# #Объявим адрес по котором будут обращаться клиенты
# @app.get("/")#тут мы пишем декоратор с названием приложения и метод как используем функцию (методы: get, put, delete...) в скобках пишем точку входа. корень будет /
# def get_hello():
#     return "Hello World"
#как запустить сервер!!!!!!!!!!!!!!!!!
#без активации виртуального окружения не запускается сервер uvicorn
#uvicorn - это веб сервер который обрабатывает запросы, получает и отдает данные
#команда ЗАПУСКА ВЕБ СЕРВЕРА: uvicorn main:app --reload и номер порта на котором запускается сервер, но это не обяз, reload это чтобы приложение автоматом перезагружалось при изменениях
#если прописать после адреса корневой страницы /docs то откроется документация к api
# есть еще вторая версия документации redoc. На страницах документации можно смотреть какие функции есть там и какие параметры у них
# в документации пишутся методы названия методов и их параметры и ответы от сервера и значение которое возвращается. ТАм можно смотреть всякие запросы к серверу и тд
# from fastapi import FastAPI
# app = FastAPI(
# title ="My App"
#     )
#
#
# fake_users = [
# {"id": 1, "role": "admin", "name": "Bob"},
# {"id": 2, "role": "investor", "name": "John"},
# {"id": 3, "role": "trader", "name": "Matt"}
# ]#это типа база данных
#
# @app.get("/users/{user_id}")#этот текст можно распарсить и забрать как переменную user_id, она должна быть в фигурных скобках, это эндпоин то есть путь к юзеру
# def get_hello(user_id: int):
#     return [user for user in fake_users if user.get("id") == user_id]# вернется нужный нам юзер по номеру
# #теперь в docs док-ции фаст апи можно нажать Try it out и ввести единицу в параметр user_id функции. и выведется единица,
# #параметры в декораторе приложения являются строками. Нужно прописать подсказку типов, и тогда метод будет видеть инт. Также на странице документации будет написано название типа этого пути. Это удобно что все пользователи и разрабы будут видеть какой там тип должен быть и также ide подсказывает методы которые можно применять к этому параметру для каких либо действия
# # сделаем запрос из списка сделок
# # база списка сделок для одного и того же пользователя
# fake_trades = [
# {"id": 1, "user_id": 1, "currency": "BTC", "side": "buy", "price": 123, "amount": 2.12},
# {"id": 2, "user_id": 1, "currency": "BTC", "side": "sell", "price": 321, "amount": 2.12}
# ]
#
# @app.get("/trades")#trades это эндпоинт, точка конца
# def get_trades(limit: int = 1, offset: int = 0):#limit колво получаемых сделок, offset это сдвиг по списку сделок. Можно задавать формальные параметры чтобы был один и тот же запрос
#     return fake_trades[offset:][:limit]#как бы берем список и берем из этого списка лимит то есть опять еще один индекс. То есть срез среза получается. Если прописать формальные параметры, то в документации пропадут надписи required и можно не писать эти параметры
# # в функциях возвращается питоновский объект и она сама конвертируется в json, фастапи сам конвертирует
#
#
# fake_users2 = [
# {"id": 1, "role": "admin", "name": "Bob"},
# {"id": 2, "role": "investor", "name": "John"},
# {"id": 3, "role": "trader", "name": "Matt"}
# ]
#
# #обратимся к стилю проектирования апи rest. Напишем пост запрос. МОжно писать какие дангные принимаем и отджаем и обрабатываем. Там также используются эндпоинты, то есть начальные пути
# @app.post("/users/{user_id}")
# def change_user_name(user_id: int, new_name: str):#функция будет менять имя у пользователя в базе данных
#     current_user = list(filter(lambda user: user.get("id") == user_id, fake_users2))[0]
#     current_user["name"] = new_name
#     return {"status": 200, "data": current_user}


# FastAPI - Валидация данных с Pydantic #3!!!!!!!

from fastapi import FastAPI
from pydantic import BaseModel, Field
import uvicorn
from typing import List
from fastapi_users import fastapi_users

app = FastAPI()

fake_users = [
{"id": 1, "role": "admin", "name": "Bob"},
{"id": 2, "role": "investor", "name": "John"},
{"id": 3, "role": "trader", "name": "Matt", "degree": [
{"id": 1, "created_at": "2020-01-01T00:00:00", "type_degree": "expert"}
]},#тут добавилась новое поле роль, это может быть эксперт или новичок или еще что-то. Эти поля нужно прописать в классе
]



fake_trades = [
{"id": 1, "user_id": 1, "currency": "BTC", "side": "buy", "price": 123, "amount": 2.12},
{"id": 2, "user_id": 1, "currency": "BTC", "side": "sell", "price": 321, "amount": 2.12}
]

class Trade(BaseModel):#при указании в функции такой модели туда будет передан словарь из этих полей. И при передаче полей там будут преобразоываться типы в случае если это возможно, если невозможно то будет ошибка выдаваться, например в документации. В случа если нужно какое то условие для валидации можно импортировать Field из pydentic
    id: int
    user_id: int
    currency: str = Field(max_length=5)#ограничение по длинне например можно сделать
    side: str
    price: float = Field(ge=0)#ge означает >=, то есть поле цена(price) >= 0
    amount: float


class Degree(BaseModel):
    id: int
    created_at: datetime
    type_degree: str#тут остановился



class User(BaseModel):
    id: int
    role: str
    name: str
    degree: List[Degree]#можноуказывать вместо типа данных указать свой класс и его описать

#валидация анных которые мы отправляем, то есть клиент хочет получить юзера и его валидируем перед получением клиентом. Это нужно в случае если на фронте структура какая-то и нужно чтобы и с бэка тоже все норм приходило. Для этого в параметрах декоратора пишем response_model
@app.get('/users/{user_id}', response_model=List[User])#передаем сюда список юзеров, это должен быть класс, и теперь у нас будут прописаны конкретные типы для наших данных, без этого выводились просто любые данные которые мы укажем в словаре или БД. Теперь тип данных из бд должен соответствовать тому типу в классе User. Также есть и более сложные валидации со множеством вложений. 
def get_user(user_id: int):
    return [user for user in fake_users if user.get("id") == user_id ]

@app.post("/trades")
def add_trades(trades: List[Trade]):#сюда передали класс, это список запросов. Параметров у функции не будет в докментации
    fake_trades.extend(trades)
    return {"status": 200, "data": fake_trades}





if __name__ == "__main__":
    uvicorn.run("main:app", port=8000, host="127.0.0.1", reload=True, workers=3)



fastapi_users = FastAPIUsers[User, int](
    get_user_manager,
    [auth_backend],
)



#роутер для аутха
app.include_router(
    fastapi_users.get_auth_router(auth_backend),
    prefix="/auth/jwt",
    tags=["auth"],
)
# роутер для регистрации 
app.include_router(
    fastapi_users.get_register_router(UserRead, UserCreate),
    prefix="/auth",
    tags=["auth"],
)


current_user = fastapi_users.current_user()

@app.get("/protected-route")
def protected_route(user: User = Depends(current_user)):
    return f"Hello, {user.username}"


@app.get("/unprotected-route")
def unprotected_route():
    return f"Hello, anonym"

















































# #Новый курс, короткий
# # https://www.youtube.com/watch?v=hmZe7gOrdSo&list=PLaED5GKTiQG8GW5Rv2hf3tRS-d9t9liUt&index=3
# from fastapi import FastAPI
# from schemas import Book#импортировали класс с моделью

# app = FastAPI()

# @app.get('/')
# def home():
#     return {"key": "Hello world"}
# #построение урл

# @app.get('/{pk}')#this is url. Это просто функция, которая принимает параметр и возвращает его
# def get_item(pk: int, q: int = None):
#     return {"key": pk, "q": q}
# #эти параметры можно писать в адресной строке. То есть этот то что пишется в скобках тут @app.get('/{pk}') это ссылка. Если написали просто слеш, то это будет корень сайта, то есть просто IP адрес. Если написать параметр в фигурных скобках, то будет ссылка IP и наш параметр, потом знак ? потом второй параметр q и его значение, пишем знак ? потому что в адресе в декораторе больше нет параметров, поэтому так пишется через ?. В нашем случае это должно быть число
# #получается такая ссылка для этой функции выше: http://127.0.0.1:8000/3?q=3, если по ней перейти то на странице будет выведено то что возвращает функция

# #следующая ссылка
# @app.get('/user/{pk}/items/{item}/')#pk это идентификатор нашего пользователя и итем и имя итема, просто предмет скорее всего. Теперь урлка будет выглядеть так как прописано в скобках в декораторе приложения. Пример ссылки: http://127.0.0.1:8000/user/555/items/telek/. Если написать значение строки русскими буквами будут странные значки англ букв и значки %
# def get_user_item(pk: int, item: str):
#     return {"user": pk, "item": item}

# #в документации в поле Curl пишется сформированная ссылка. Response body там значения нашего сформированного словаря который возвращается.
# #далее создадим новый файл для сериализации

# #напишем функцию которая принимает запрос основываясь на нашей модели Book. то есть создаем книгу
# @app.post('/book')
# def create_book(item: Book):#после двоеточия пишется тип данных. В нашем случае это наш класс Book
#     return item
# #теперь при запуске можно будет редачить словарь со значениями полей класса Book. Там где тип строка и если в этом поле ввести число, то оно преобразуется в строку







